# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'AUTOMATICO.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from math import pi
from std_msgs.msg import String, Float32
from moveit_commander.conversions import pose_to_list
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Joy
import os
import subprocess 

from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_AUTOMATICO(object):
    def setupUi(self, AUTOMATICO):
        
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()
        self.group_name = "manipulator"
        self.move_group = moveit_commander.MoveGroupCommander(self.group_name)

        self.planning_frame = self.move_group.get_planning_frame()
        print("============ Planning frame: %s" % self.planning_frame)

        # We can also print the name of the end-effector link for this group:
        self.eef_link = self.move_group.get_end_effector_link()
        print("============ End effector link: %s" % self.eef_link)

        # We can get a list of all the groups in the robot:
        self.group_names = self.robot.get_group_names()
        print("============ Available Planning Groups:", self.robot.get_group_names())

        # Sometimes for debugging it is useful to print the entire state of the
        # robot:
        print("============ Printing robot state")
        print(self.robot.get_current_state())
        print("") 
        
        #rospy.Subscriber("joy", Joy, self.control) 
        rospy.Subscriber('position_state_x', Float32, self.state_x)
        rospy.Subscriber('position_state_y', Float32, self.state_y)
        #rospy.Subscriber('position_state_x', Float32, callback)
        #rospy.Subscriber('position_state_y', Float32, callback1)
    #---------------------MOTORES---------------------------------
        
        self.M1=0.0
        self.M2=0.0
        self.M3=1.47
        self.M4=0.0
        self.M5=1.24
        self.M6=1.58
        self.plano()

        self.MJ1=0.0
        self.MJ2=0.0
        self.MJ3=0.0
        #-------------------------------------------------------------------------------------
       
        AUTOMATICO.setObjectName("AUTOMATICO")
        AUTOMATICO.resize(212, 231)
        self.label = QtWidgets.QLabel(AUTOMATICO)
        self.label.setGeometry(QtCore.QRect(20, 40, 171, 19))
        self.label.setObjectName("label")
        self.checkBox = QtWidgets.QCheckBox(AUTOMATICO)
        self.checkBox.setGeometry(QtCore.QRect(50, 70, 111, 25))
        self.checkBox.setObjectName("checkBox")
        self.checkBox_2 = QtWidgets.QCheckBox(AUTOMATICO)
        self.checkBox_2.setGeometry(QtCore.QRect(50, 110, 111, 25))
        self.checkBox_2.setObjectName("checkBox_2")
        self.checkBox_3 = QtWidgets.QCheckBox(AUTOMATICO)
        self.checkBox_3.setGeometry(QtCore.QRect(50, 150, 111, 25))
        self.checkBox_3.setObjectName("checkBox_3")
        self.label_2 = QtWidgets.QLabel(AUTOMATICO)
        self.label_2.setGeometry(QtCore.QRect(20, 10, 171, 19))
        self.label_2.setStyleSheet("background-color: rgb(255, 255, 255);")
        self.label_2.setObjectName("label_2")
        self.pushButton = QtWidgets.QPushButton(AUTOMATICO)
        self.pushButton.setGeometry(QtCore.QRect(30, 190, 61, 27))
        self.pushButton.setObjectName("pushButton")
        self.pushButton_2 = QtWidgets.QPushButton(AUTOMATICO)
        self.pushButton_2.setGeometry(QtCore.QRect(110, 190, 61, 27))
        self.pushButton_2.setObjectName("pushButton_2")
        self.counter=0
        self.counter1=0
        self.counter2=0
        self.on=0

        self.retranslateUi(AUTOMATICO)
        self.checkBox.toggled['bool'].connect(self.motor1)
        self.checkBox_2.toggled['bool'].connect(self.motor2)
        self.checkBox_3.toggled['bool'].connect(self.motor3)
        self.pushButton.clicked.connect(self.start)
        self.pushButton_2.clicked.connect(self.stop)
        QtCore.QMetaObject.connectSlotsByName(AUTOMATICO)

    def retranslateUi(self, AUTOMATICO):
        _translate = QtCore.QCoreApplication.translate
        AUTOMATICO.setWindowTitle(_translate("AUTOMATICO", "Form"))
        self.label.setText(_translate("AUTOMATICO", "Elección de motores:"))
        self.checkBox.setText(_translate("AUTOMATICO", "Motor1 (J1)"))
        self.checkBox_2.setText(_translate("AUTOMATICO", "Motor2 (J2)"))
        self.checkBox_3.setText(_translate("AUTOMATICO", "Motor3 (J3)"))
        self.label_2.setText(_translate("AUTOMATICO", "MODO AUTOMÁTICO"))
        self.pushButton.setText(_translate("AUTOMATICO", "START"))
        self.pushButton_2.setText(_translate("AUTOMATICO", "STOP"))
    
    def motor1(self):
        
        if self.counter==0:
            self.MJ1=1
            print(self.MJ1)
            self.counter+=1
        else:
            self.MJ1=0
            self.counter=0
            print(self.MJ1) 
        print("motor1")

    def motor2(self):
        
        if self.counter1==0:
            self.MJ2=1
            print(self.MJ2)
            self.counter1+=1
        else:
            self.MJ2=0
            self.counter1=0
            print(self.MJ2)
        
        print("motor2")
        
    def motor3(self):
        
        if self.counter2==0:
            self.MJ3=1
            print(self.MJ3)
            self.counter2+=1
        else:
            self.MJ3=0
            self.counter2=0
            print(self.MJ3)
        
        print("motor3")
    def start(self):
        self.on=1 
        print(self.on)
        print("start")
    def stop(self):
        self.on=0
        print(self.on)
        print("stop")

    def plano(self):
        
        print('Entre a la funcion planear')
        # We can get the joint values from the group and adjust some of the values:
        self.joint_goal = self.move_group.get_current_joint_values()
        print(self.joint_goal)

        # joint_goal[1] = 0
        # joint_goal[2] = 0
        # joint_goal[3] = 0
        # joint_goal[4] = 0
        # joint_goal[5] = 0
        # joint_goal[6] = 0
       
        #cambiar joint values
        self.joint_goal[0] = float(self.M1)    #  // radians
        self.joint_goal[1] = float(self.M2)    #  // radians-0.6   1.37
        self.joint_goal[2] = float(self.M3) #  // radians 0 2.5
        self.joint_goal[3] = float(self.M4) #  // radians -2.7 
        self.joint_goal[4] = float(self.M5)#  // radians 1.8
        self.joint_goal[5] = float(self.M6) #  // radians 2.3
        
       
        # The go command can be called with joint values, poses, or without any
        # parameters if you have already set the pose or joint target for the group
        self.move_group.set_joint_value_target(self.joint_goal)
        self.plan = self.move_group.go( wait=True)
        #plan = move_group.go(joint_goal, wait=True)
        print("after planning")
        # Calling ``stop()`` ensures that there is no residual movement
        self.move_group.stop()
        #joint_goal[0] =1.57  #;  // radians
        #joint_goal[1] = 0.0 #;  // radians
        #joint_goal[2] = 0.0 #;  // radians
        #joint_goal[3] = 0.0 #  // radians
        #joint_goal[4] = 0.0 #;  // radians
        #joint_goal[5] = 0.0 #;  // radians
        #move_group.execute(plan,  wait=True)
        #move_group.set_joint_value_target(joint_goal)
        # plan = move_group.go( wait=True)
        rospy.sleep(10)                                                 
        print("end")
    
    def state_x(self,data):
        print("MJ1=", self.MJ1)
        print("START=",self.on)

        if self.MJ1==1 and self.on==1:
 
            self.xp=data.data
            self.xpi= 320-self.xp
            print(self.xpi)

            if self.xpi < -15 and self.xpi>-50:
                self.M1 +=0.01 #RAD
                self.plano()

            if self.xpi < -50:
                self.M1 +=0.04 #RAD
                self.plano()

            if self.xpi> 15 and self.xpi < 50 :
                self.M1 -=0.01
                self.plano()

            if self.xpi> 50 :
                self.M1 -=0.01
                self.plano()
            
            return self.xp
        

    def state_y(self,data): 

        if  self.MJ2==0 and self.MJ3==1 and self.on==1:
            
            self.yp=data.data
            
            self.ypi= 240-self.yp
            print(self.ypi)
            
            
            if self.ypi < -20 and self.ypi>-100: #and M3 != 2 and M2<=1.4:
                self.M3 +=0.01 #RAD
                self.plano()
            if self.ypi < -100: #and M3 != 2 and M2<=1.4:
                self.M3 +=0.03  #RAD
                self.plano()
            #if M3==2:
            #	while M3 >= 0.5 and ypi < -20 and M2 <= 1.4 : 
            #		M2 +=0.02 #RAD
            #		M3 -=0.02 #RAD
            #                planear()

            if self.ypi > 20 and self.ypi < 100  : #and M2 != -1 and M3< 1:
                self.M3 -=0.01  #RAD
                self.plano()

            if self.ypi > 100: #and M2 != -1 and M3< 1:
                self.M3 -=0.03  #RAD
                self.plano()
                
            return self.yp
            
        if self.MJ2==1 and self.MJ3==1 and self.on==1:
            
            self.yp=data.data
            
            self.ypi= 240-self.yp
            print(self.ypi)
            
            
            if self.ypi < -20 and self.ypi>-100: #and M3 != 2 and M2<=1.4:
                self.MJ3+=0.01#RAD
                self.plano()
            if self.ypi < -100: #and M3 != 2 and M2<=1.4:
                self.M3 +=0.03  #RAD
                self.plano()
            #if M3==2:
            #	while M3 >= 0.5 and ypi < -20 and M2 <= 1.4 : 
            #		M2 +=0.02 #RAD
            #		M3 -=0.02 #RAD
                #                planear()

            if self.ypi > 20 and self.ypi < 100  : #and M2 != -1 and M3< 1:
                self.M3 -=0.01 #RAD
                self.plano()

            if self.ypi > 100: #and M2 != -1 and M3< 1:
                self.M3 -=0.03 #RAD
                self.plano()
            return self.yp

if __name__ == "__main__":
    import sys

    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node('robot_plan', anonymous=True)
    rospy.loginfo("robot_plan")
    
    app = QtWidgets.QApplication(sys.argv)
    AUTOMATICO = QtWidgets.QWidget()
    ui = Ui_AUTOMATICO()
    ui.setupUi(AUTOMATICO)
    AUTOMATICO.show()
    sys.exit(app.exec_())
